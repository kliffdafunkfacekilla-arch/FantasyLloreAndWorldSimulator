#define STB_IMAGE_IMPLEMENTATION
#include "../io/stb_image.h"
#include "../../include/SimulationModules.hpp"
#include <iostream>
#include <algorithm>
#include <cmath>

void LoadHeightmapData(const char* path, WorldBuffers& buffers, uint32_t count) {
    int imgW, imgH, channels;
    unsigned char* data = stbi_load(path, &imgW, &imgH, &channels, 1); // Load as grayscale

    if (!data) {
        std::cerr << "Failed to load heightmap: " << path << std::endl;
        return;
    }

    // Assume square world for simplicity in mapping 1D index to 2D
    // If we had map dimensions passed in, we'd use them.
    // Given count, we estimate width ~ sqrt(count)
    int mapW = (int)std::sqrt(count);
    int mapH = mapW;
    
    // Safety check
    if (mapW == 0) mapW = 1000;
    if (mapH == 0) mapH = 1000;

    for (uint32_t i = 0; i < count; ++i) {
        // We need X,Y coords. 
        // If they are generated by Poisson, we use them.
        // If not generated yet (e.g. grid mode), we might infer them.
        // Assuming buffers.posX/Y are populated. 
        // If they are NOT populated (nullptr or garbage), this will crash or give garbage.
        // Usually, point generation happens BEFORE heightmap loading in the flow.
        
        float x = (buffers.posX) ? buffers.posX[i] : (float)(i % mapW);
        float y = (buffers.posY) ? buffers.posY[i] : (float)(i / mapW);

        // Map world coordinate to image coordinate
        int pixelX = (int)((x / mapW) * imgW);
        int pixelY = (int)((y / mapH) * imgH);
        
        // Ensure within bounds
        pixelX = std::max(0, std::min(imgW - 1, pixelX));
        pixelY = std::max(0, std::min(imgH - 1, pixelY));

        // Assign 0.0 to 1.0 based on pixel brightness
        if (buffers.height) {
            buffers.height[i] = data[pixelY * imgW + pixelX] / 255.0f;
        }
    }

    stbi_image_free(data);
    std::cout << "[IO] Heightmap applied to " << count << " cells." << std::endl;
}
